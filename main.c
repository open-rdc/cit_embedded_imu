///************************************************************/// LED フリーラン点滅　//　　　　　　　　　周期　２sec　（ON：1sec　OFF:1sec）//************************************************************/#include	"p24FJ64GA004.h"#include	<stdio.h>#include	<stdlib.h>#include 	<uart.h>#include 	<spi.h>#include	<timer.h>#include	"types.h"#include	"adisUtils.h"#include	"picUtils.h"/// コンフィギュレーション ビットの設定_CONFIG1( JTAGEN_OFF &  //JTAGポート：　OFF			 GCP_OFF &      //コードプロテクト：　OFF			GWRP_OFF &      //書き込みプロテクト：　OFF			BKBUG_OFF &     //バックグランドデバック：　OFF			COE_OFF &       //クリップオン　エミュレーション：　OFF 			ICS_PGx3&       //ICDピンの選択：　EMUC/EMUDをPGC3/PGD3と共用			FWDTEN_OFF )//ウォッチドックタイマ：　OFF _CONFIG2( IESO_OFF &    // ２速度スタートアップ機能：OFF		//FNOSC_FRCPLL &  //内臓高速RC発振（8MHZ)回路　＋　4倍PLL　→　32MHｚ（=　8MHz　×　4）		FNOSC_PRIPLL & //外部高速水晶発振回路(8MHz)　＋　4倍PLL　→　32MHz		FCKSM_CSDCMD &  //クロック切替え制御：OFF　クロックモニタ：OFF		OSCIOFNC_OFF &  //OSCO/RC15 function：　OSCO or Fosc/2		IOL1WAY_OFF &   //RP Register Protection：　Unlimited Writes To RP Registersn		I2C1SEL_PRI &   //I2C1 pins Select：　Use Primary I2C1 pins		//POSCMOD_NONE)   //発振回路モード　Oscillator Selection:　 Primary disabled		POSCMOD_HS)   //発振回路モード　Oscillator Selection:　 Primary disabled#define OFF	0#define ON	1char imuEnable = OFF;char uartEnable = ON;long timercounter;void _ISR _T1Interrupt(void){	IFS0bits.T1IF = 0;	if(imuEnable == ON)	imu_readSensor();}void localEcho(void){	while(!DataRdyUART1());	putcUART1(getcUART1());	while(BusyUART1());}void systemInitialize(void){	RCONbits.EXTR = 1; // MCLR	CLKDIV = 0;     //Clock Divider register: 分周なし →　32MHｚ　CPU Peripheral Clock Ratio = 1:1				//CPU Peripheral Clock Ratio Select bits CLKDIV<14:12>)				//111 = 1:128				//110 = 1:64				//101 = 1:32				//100 = 1:16				//011 = 1:8				//010 = 1:4				//001 = 1:2				//000 = 1:1		AD1PCFG = 0xFFFF; //ポートANを全てデジタルI/Oとする	TRISB = 0x04;      //3:MOSI, 2:MISO, 1:SCLK, 0:SS	TRISC = 0x01;	//RP16:RC0, RP17:RC1	initUART();	initSPI();	}void configTimer1(int arg){	static int scale = 0;	DisableIntT1;	CloseTimer1();	scale += arg;	myOpenTimer1_us(			T1_ON   &       //タイマ１ON			T1_GATE_OFF &   //ゲート制御off			T1_SYNC_EXT_OFF &       //クロック同期制御OFF			T1_SOURCE_INT,          //クロック源：内部クロック			T1_PS_1_8,            //プリスケーラ			//9804						//周期 10msec			//850 + scale			813 + scale	);	EnableIntT1;}/// メイン関数int main(void){	char str[32];	float x,y,z;	//WORD temp;        DWORD sum;	systemInitialize();		myOpenTimer1_us(			T1_ON   &       //タイマ１ON			T1_GATE_OFF &   //ゲート制御off			T1_SYNC_EXT_OFF &       //クロック同期制御OFF			T1_SOURCE_INT,          //クロック源：内部クロック			T1_PS_1_8,            //プリスケーラ			//9804						//周期 10msec			//850			813						//1230Hz	);	ConfigIntTimer1(T1_INT_PRIOR_5 & T1_INT_ON);    //割込みレベル５、　タイマ１割込みON	EnableIntT1;	delay_ms(100);	putsUART1("\r\n\n");	putsUART1("imu_adisUtil_init()\r\n");        imu_adisUtil_init();	delay_ms(1);	delay_s(1);    	// biasNullコマンドは，avg_dec_filterより前に呼ぶ必要があるっぽい	putsUART1("imu_biasNull_setAverageTime()\r\n");	// TC_106_563SEC: 0.000297108353414097% / sec	imuEnable = ON;    	//avg_dec_filterはIMUへの送信ループが開始してから呼び出す必要があるっぽい	putsUART1("imu_avg_dec_filter()\r\n");        imu_avg_dec_filter(1000.0); // xSPS	delay_ms(1);	imu_clearAngle();	imu_clearVelocity();/*	imu_setGyroScale_x(0);	imu_setGroScale_y(0);	imu_setGyroScale_z(0);*/	while(1)	{		if(DataRdyUART1())		{			switch(getcUART1())			{				case 'a':					imuEnable = OFF;					imu_biasNull_setAverageTime(							TC_6_660SEC,						/*	BIAS_ENABLE_ACCL_X |							BIAS_ENABLE_ACCL_Y |							BIAS_ENABLE_ACCL_Z | */							BIAS_ENABLE_GYRO_X |							BIAS_ENABLE_GYRO_Y |							BIAS_ENABLE_GYRO_Z);					delay_s(1);					putsUART1("\r\n\n  Now calliburation!\r\n");					putsUART1("  all axis, 6.6sec\r\n\n");					delay_s(8);					imu_biasNull();					imu_flashMemoryUpdate();					putsUART1(" Complete!\r\n");					imuEnable = ON;					break;				case 'b':					sprintf(str, "%04X", imu_baro_w);					putsUART1(str);					putsUART1("\r\n");					break;				case 'e':					sprintf(str, "%04X", dwordHigh(imu_angle.dw.x));					putsUART1(str);					sprintf(str, "%04X", dwordHigh(imu_angle.dw.y));					putsUART1(str);					sprintf(str, "%04X", dwordHigh(imu_angle.dw.z));					putsUART1(str);/*					sprintf(str, "%07ld", (long)(imu_angle.f.x*10000));					putsUART1(str);					sprintf(str, "%07ld", (long)(imu_angle.f.y*10000));					putsUART1(str);					sprintf(str, "%07ld", (long)(imu_angle.f.z*10000));					putsUART1(str);*/					putsUART1("\r\n");					break;				case 'f':					imu_getFirmwareRevision();					putsUART1("Firmware Revision ");					sprintf(str, "%X", imu_firmrev);					putsUART1(str);					putsUART1(" ");					sprintf(str, "%4X", imu_firmrev_y);					putsUART1(str);					putsUART1("-");					sprintf(str, "%4X", imu_firmrev_dm);					putsUART1(str);					putsUART1("\r\n");					delay_s(1);					break;				case 'g':					sprintf(str, "%04X", dwordHigh(imu_accele.dw.x));					putsUART1(str);					sprintf(str, "%04X", dwordHigh(imu_accele.dw.y));					putsUART1(str);					sprintf(str, "%04X", dwordHigh(imu_accele.dw.z));					putsUART1(str);					putsUART1("\r\n");					break;				case 't':					sprintf(str, "%04X", imu_temp_w);					putsUART1(str);					putsUART1("\r\n");					break;				case 'm':					sprintf(str, "%04X", dwordLow(imu_magneto.dw.x));					putsUART1(str);					sprintf(str, "%04X", dwordLow(imu_magneto.dw.y));					putsUART1(str);					sprintf(str, "%04X", dwordLow(imu_magneto.dw.z));					putsUART1(str);					putsUART1("\r\n");					break;				case 'o':                                        sum = 0;                                        sum = sum ^ imu_angle.dw.x;					sprintf(str, "%04X", dwordHigh(imu_angle.dw.x));					putsUART1(str);                                        sum = sum ^ imu_angle.dw.y;					sprintf(str, "%04X", dwordHigh(imu_angle.dw.y));					putsUART1(str);                                        sum = sum ^ imu_angle.dw.z;					sprintf(str, "%04X", dwordHigh(imu_angle.dw.z));					putsUART1(str);                                        sprintf(str, "%04X", sum);                                        putsUART1(str);					putsUART1("\r\n");					break;				case 's':					putsUART1("\r\n  Self test\r\n");					imu_selfTest();					putsUART1("Result : ");					sprintf(str, "%04X", imu_diag);						putsUART1(str);									putsUART1("\r\n");					break;				case 'r':					imu_factoryCalibrationRestore();					imu_flashMemoryUpdate();					//imu_softwareReset();					putsUART1("\r\n  Factory calibration restore\r\n");										delay_s(1);					break;				case 'x':					imuEnable = OFF;					delay_ms(1);					imu_scaleGyroIncrimental_x(1);					sprintf(str, "XSCL: %x\n\r", imu_getGyroScale_x());					putsUART1(str);					imuEnable = ON;					break;				case 'X':					imuEnable = OFF;					delay_ms(1);					imu_scaleGyroIncrimental_x(-1);					sprintf(str, "XSCL: %x\n\r", imu_getGyroScale_x());					putsUART1(str);					imuEnable = ON;					break;				case 'y':					imuEnable = OFF;					imu_scaleGyroIncrimental_y(1);					sprintf(str, "YSCL: %x\n\r", imu_getGyroScale_y());					putsUART1(str);					imuEnable = ON;					break;				case 'Y':					imuEnable = OFF;					imu_scaleGyroIncrimental_y(-1);					sprintf(str, "YSCL: %x\n\r", imu_getGyroScale_y());					putsUART1(str);					imuEnable = ON;					break;				case 'z':					imuEnable = OFF;					imu_scaleGyroIncrimental_z(1);					sprintf(str, "ZSCL: %x\n\r", imu_getGyroScale_z());					putsUART1(str);					imuEnable = ON;					break;				case 'Z':					imuEnable = OFF;					imu_scaleGyroIncrimental_z(-1);					sprintf(str, "ZSCL: %x\n\r", imu_getGyroScale_z());					putsUART1(str);					imuEnable = ON;					break;				case '0':					imu_clearAngle();					imu_clearVelocity();					break;			}		}		/*		if(0x8000>temp && temp>0x1C64)		{			putsUART1("  upper\r\n");		}		if(0xE39B>temp && temp>0x8000)		{			putsUART1("  lower\r\n");		}		*/		//putsUART1("\n\r");	}	return 0;}